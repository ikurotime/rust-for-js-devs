---
title: Construyendo un Juego de Adivinanzas
description: Crea un simple juego de adivinanzas en Rust y compáralo con la implementación en JavaScript
---

# Construyendo un Juego de Adivinanzas

Ahora que hemos cubierto lo básico, vamos a construir un simple juego de adivinanzas para entender mejor Rust. Construiremos la misma aplicación tanto en Rust como en JavaScript para destacar las diferencias y similitudes.

## Descripción del Proyecto

Crearemos un juego de adivinanzas de números donde:
1. El programa genera un número aleatorio entre 1 y 100
2. El jugador introduce sus suposiciones
3. El programa proporciona retroalimentación sobre cada intento
4. El juego continúa hasta que el jugador adivine correctamente

## Configurando el Proyecto en Rust

Comencemos creando un nuevo proyecto de Rust:

```bash
cargo new guessing_game
cd guessing_game
```

## El Programa Inicial en Rust

Abre `src/main.rs` y reemplaza su contenido con:

```rust
use std::io;

fn main() {
    println!("¡Adivina el número!");
    
    println!("Por favor, introduce tu suposición:");
    
    let mut guess = String::new();
    
    io::stdin()
        .read_line(&mut guess)
        .expect("Error al leer la línea");
        
    println!("Has adivinado: {}", guess);
}
```

## Equivalente en JavaScript

Para comparar, así es como comenzaríamos en JavaScript:

```javascript
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

console.log("¡Adivina el número!");

console.log("Por favor, introduce tu suposición:");

readline.question('', (guess) => {
  console.log(`Has adivinado: ${guess}`);
  readline.close();
});
```

## Entendiendo el Código de Rust

Vamos a desglosar el código de Rust:

1. `use std::io;` - Importa la biblioteca de E/S (similar a `require` en Node.js)
2. `let mut guess = String::new();` - Crea una variable mutable (nota el `mut`)
3. `io::stdin().read_line(&mut guess)` - Obtiene la entrada del usuario y la almacena en `guess`
4. `.expect("Error al leer la línea")` - Maneja posibles errores (exploraremos mejor manejo de errores más adelante)

Diferencias clave respecto a JavaScript:
- Las variables son inmutables por defecto en Rust; necesitamos `mut` para hacerlas mutables
- En Rust, manejamos los errores explícitamente con `.expect()` u otros métodos de manejo de errores

## Añadiendo Generación de Números Aleatorios

Actualicemos nuestro programa para generar un número aleatorio. Primero, necesitamos añadir el crate `rand` a nuestras dependencias.

Edita `Cargo.toml`:

```toml
[dependencies]
rand = "0.8.5"
```

Ahora, actualiza `src/main.rs`:

```rust
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("¡Adivina el número!");
    
    let secret_number = rand::thread_rng().gen_range(1..=100);
    
    println!("El número secreto es: {}", secret_number); // Para depuración
    
    println!("Por favor, introduce tu suposición:");
    
    let mut guess = String::new();
    
    io::stdin()
        .read_line(&mut guess)
        .expect("Error al leer la línea");
        
    let guess: u32 = guess.trim().parse().expect("¡Por favor, escribe un número!");
        
    println!("Has adivinado: {}", guess);
    
    match guess.cmp(&secret_number) {
        Ordering::Less => println!("¡Demasiado pequeño!"),
        Ordering::Greater => println!("¡Demasiado grande!"),
        Ordering::Equal => println!("¡Has ganado!"),
    }
}
```

## Equivalente en JavaScript

```javascript
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

console.log("¡Adivina el número!");

const secretNumber = Math.floor(Math.random() * 100) + 1;

console.log(`El número secreto es: ${secretNumber}`); // Para depuración

console.log("Por favor, introduce tu suposición:");

readline.question('', (guessInput) => {
  const guess = Number(guessInput.trim());
  
  console.log(`Has adivinado: ${guess}`);
  
  if (guess < secretNumber) {
    console.log("¡Demasiado pequeño!");
  } else if (guess > secretNumber) {
    console.log("¡Demasiado grande!");
  } else {
    console.log("¡Has ganado!");
  }
  
  readline.close();
});
```

## Diferencias Clave Hasta Ahora

1. **Manejo de Errores**: 
   - Rust: Explícito con `.expect()` u otros métodos
   - JavaScript: A menudo implícito o con bloques try/catch

2. **Conversión de Tipos**:
   - Rust: Análisis explícito con `.parse()` para convertir strings a números
   - JavaScript: Conversión implícita o explícita con `Number()`

3. **Comparación**:
   - Rust: Usa coincidencia de patrones con la expresión `match`
   - JavaScript: Usa declaraciones if/else

## Añadiendo un Bucle para Múltiples Intentos

Actualicemos nuestro programa en Rust para permitir múltiples intentos:

```rust
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("¡Adivina el número!");
    
    let secret_number = rand::thread_rng().gen_range(1..=100);
    
    loop {
        println!("Por favor, introduce tu suposición:");
        
        let mut guess = String::new();
        
        io::stdin()
            .read_line(&mut guess)
            .expect("Error al leer la línea");
            
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("¡Por favor, escribe un número!");
                continue;
            }
        };
            
        println!("Has adivinado: {}", guess);
        
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("¡Demasiado pequeño!"),
            Ordering::Greater => println!("¡Demasiado grande!"),
            Ordering::Equal => {
                println!("¡Has ganado!");
                break;
            }
        }
    }
}
```

## Equivalente en JavaScript

```javascript
const readline = require('readline');

function guessTheNumber() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  console.log("¡Adivina el número!");
  
  const secretNumber = Math.floor(Math.random() * 100) + 1;
  
  const askGuess = () => {
    rl.question('Por favor, introduce tu suposición: ', (guessInput) => {
      const guess = Number(guessInput.trim());
      
      if (isNaN(guess)) {
        console.log("¡Por favor, escribe un número!");
        askGuess();
        return;
      }
      
      console.log(`Has adivinado: ${guess}`);
      
      if (guess < secretNumber) {
        console.log("¡Demasiado pequeño!");
        askGuess();
      } else if (guess > secretNumber) {
        console.log("¡Demasiado grande!");
        askGuess();
      } else {
        console.log("¡Has ganado!");
        rl.close();
      }
    });
  };
  
  askGuess();
}

guessTheNumber();
```

## Manejo de Errores Mejorado

Observa cómo nuestro código Rust ahora usa coincidencia de patrones para manejar posibles errores al analizar la entrada:

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => {
        println!("¡Por favor, escribe un número!");
        continue;
    }
};
```

Esto usa el tipo `Result` de Rust, que exploraremos más en la sección de manejo de errores.

## Ejecutando el Juego Completo

Ejecuta la versión de Rust:

```bash
cargo run
```

## Comparando las Implementaciones Completas

Destaquemos las diferencias clave entre nuestras implementaciones en Rust y JavaScript:

1. **Seguridad de Memoria**: 
   - Rust garantiza la seguridad de memoria en tiempo de compilación
   - JavaScript depende de comprobaciones en tiempo de ejecución y recolección de basura

2. **Manejo de Errores**:
   - Rust usa tipos Result que nos obligan a manejar errores explícitamente
   - JavaScript típicamente usa bloques try/catch o callbacks para el manejo de errores

3. **Sistema de Tipos**:
   - Rust es estáticamente tipado, requiriendo anotaciones de tipo explícitas
   - JavaScript es dinámicamente tipado con sistemas de tipos opcionales como TypeScript

4. **Modelo de Concurrencia**:
   - El sistema de propiedad de Rust previene carreras de datos en tiempo de compilación
   - JavaScript usa un bucle de eventos con un solo hilo por defecto

5. **Rendimiento**:
   - Rust compila a código nativo con rendimiento similar a C/C++
   - JavaScript depende del compilador JIT del entorno de ejecución

## Próximos Pasos

Ahora que has construido un programa simple y has adquirido algo de familiaridad con Rust, profundicemos en las características del lenguaje Rust. A continuación, cubriremos [Conceptos Comunes de Programación](/es/common-concepts/variables-mutability/) con más detalle, comenzando con variables y mutabilidad. 