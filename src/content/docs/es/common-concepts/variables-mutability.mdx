---
title: Variables y Mutabilidad
description: Aprende cómo funcionan las variables y la mutabilidad en Rust en comparación con JavaScript
---

# Variables y Mutabilidad

Una de las diferencias más notables entre Rust y JavaScript es cómo funcionan las variables y la mutabilidad. Exploremos estas diferencias para ayudarte a transicionar entre los dos lenguajes.

## Variables en JavaScript

En JavaScript, puedes declarar variables con `var`, `let` o `const`:

```javascript
// Declaraciones de variables en JavaScript
var viejaEscuela = "Estoy elevado";
let mutable = "Puedo ser cambiado";
const inmutable = "No puedo ser reasignado";

// Reasignación
mutable = "Nuevo valor";  // ✅ Funciona
// inmutable = "Nuevo valor";  // ❌ TypeError: Assignment to constant variable

// Pero los objetos declarados con const SÍ pueden ser modificados
const persona = { nombre: "Alicia" };
persona.nombre = "Bob";  // ✅ ¡Funciona! Solo el enlace es inmutable
```

## Variables en Rust

Rust toma un enfoque diferente, haciendo que las variables sean **inmutables por defecto**:

```rust
// Declaraciones de variables en Rust
let inmutable = "No puedo ser cambiado"; // Inmutable por defecto
let mut mutable = "Puedo ser cambiado";  // Usa 'mut' para hacerla mutable

// Reasignación
// inmutable = "Nuevo valor";  // ❌ Error: no se puede asignar dos veces a una variable inmutable
mutable = "Nuevo valor";      // ✅ Funciona
```

## Diferencias Clave

- En JavaScript, las variables declaradas con `let` son mutables por defecto
- En Rust, las variables son inmutables por defecto y requieren `mut` para mutabilidad
- `const` en JavaScript previene la reasignación pero no la modificación de propiedades de objetos
- En Rust, la inmutabilidad es más completa (veremos más cuando lleguemos a las referencias)

## Constantes

Ambos lenguajes tienen constantes, pero funcionan de manera diferente:

### Constantes en JavaScript

```javascript
const PI = 3.14159;
// PI = 3.0;  // ❌ Error: Assignment to constant variable

// Pero los objetos pueden ser modificados
const usuario = { nombre: "Alicia" };
usuario.nombre = "Bob";  // ✅ Funciona - solo el enlace es constante, no el contenido
```

### Constantes en Rust

```rust
const PI: f64 = 3.14159;
// PI = 3.0;  // ❌ Error: no se puede asignar a esta expresión

// Las constantes requieren anotaciones de tipo y usan SCREAMING_SNAKE_CASE por convención
const MAX_PUNTOS: u32 = 100_000;
```

Las constantes en Rust:
- Deben tener anotaciones de tipo explícitas
- Solo pueden ser establecidas como una expresión constante (evaluada en tiempo de compilación)
- Pueden ser declaradas en cualquier ámbito, incluido el ámbito global
- Son insertadas en línea en tiempo de compilación

## Sombreado en Rust

Rust permite el "sombreado" de variables, que es declarar una nueva variable con el mismo nombre que una variable anterior:

```rust
let x = 5;
let x = x + 1;  // Sombrea el 'x' anterior
let x = x * 2;  // Sombrea de nuevo

println!("El valor de x es: {}", x);  // 12
```

Esto es diferente de la mutación:

```rust
// Con sombreado
let espacios = "   ";
let espacios = espacios.len();  // ✅ Funciona, el tipo puede cambiar con el sombreado

// Con mutación
let mut espacios = "   ";
// espacios = espacios.len();  // ❌ Error: tipos no coincidentes
```

### Sombreado de Variables en JavaScript

JavaScript tiene un comportamiento similar con variables de ámbito de bloque:

```javascript
let x = 5;
{
  let x = x + 1;  // Sombrea la 'x' externa
  console.log(x);  // 6
}
console.log(x);  // 5
```

Sin embargo, no puedes redeclarar la misma variable en el mismo ámbito en JavaScript:

```javascript
let x = 10;
let x = 20;  // ❌ SyntaxError: Identifier 'x' has already been declared
```

## Ámbito de las Variables

Ambos lenguajes usan llaves para definir ámbitos:

### JavaScript

```javascript
{
  let x = 10;
  console.log(x);  // 10
}
// console.log(x);  // ❌ ReferenceError: x is not defined
```

### Rust

```rust
{
    let x = 10;
    println!("x: {}", x);  // 10
}
// println!("x: {}", x);  // ❌ Error: no se puede encontrar el valor `x` en este ámbito
```

## Convenciones de Nomenclatura

### JavaScript

- `camelCase` para variables y funciones
- `PascalCase` para clases y funciones constructoras
- `SCREAMING_SNAKE_CASE` para constantes

### Rust

- `snake_case` para variables y funciones
- `PascalCase` para tipos y traits
- `SCREAMING_SNAKE_CASE` para constantes y variables estáticas

## Inferencia de Tipos

Tanto Rust como JavaScript pueden inferir tipos, pero de maneras muy diferentes:

### JavaScript (Tipado Dinámico)

```javascript
let x = 5;        // Número
x = "hola";      // Ahora es un String - ¡sin problema!
```

### Rust (Tipado Estático con Inferencia)

```rust
let x = 5;        // Inferido como i32
// x = "hola";   // ❌ Error: tipos no coincidentes

// Necesita anotación de tipo explícita para cambios de tipo
let x = 5;        // i32
let x: &str = "hola"; // Sombreado con un nuevo tipo
```

## Desestructuración

Ambos lenguajes soportan desestructuración:

### JavaScript

```javascript
const punto = { x: 10, y: 20 };
const { x, y } = punto;
console.log(x, y);  // 10 20

const numeros = [1, 2, 3];
const [primero, segundo] = numeros;
console.log(primero, segundo);  // 1 2
```

### Rust

```rust
struct Punto { x: i32, y: i32 }
let punto = Punto { x: 10, y: 20 };
let Punto { x, y } = punto;
println!("{} {}", x, y);  // 10 20

let numeros = [1, 2, 3];
let [primero, segundo, ..] = numeros;
println!("{} {}", primero, segundo);  // 1 2
```

## Mejores Prácticas

### JavaScript

- Usa `const` por defecto y `let` solo cuando sea necesaria la reasignación
- Evita `var` en código moderno
- Considera usar TypeScript para tipado estático

### Rust

- Adopta la inmutabilidad - usa `let` sin `mut` por defecto
- Usa `mut` solo cuando sea necesario
- Aprovecha el sombreado para transformaciones
- Deja que el compilador infiera los tipos cuando sean obvios

## Consideraciones de Memoria

Una diferencia importante que no es inmediatamente visible es cómo estas variables se almacenan en memoria:

### JavaScript

JavaScript maneja la asignación de memoria y la recolección de basura automáticamente. Generalmente no necesitas preocuparte por dónde viven los valores.

### Rust

En Rust, los valores pueden asignarse en la pila o en el montón, y el sistema de propiedad (que cubriremos más adelante) determina cómo se gestiona la memoria.

```rust
// Asignado en la pila
let x = 5;  

// Asignado en el montón, pero Rust abstrae la gestión de memoria
let s = String::from("hola");
```

## Próximos Pasos

Ahora que entiendes las variables y la mutabilidad en Rust, pasemos a [Tipos de Datos](/es/common-concepts/data-types/) para aprender sobre el rico sistema de tipos de Rust. 