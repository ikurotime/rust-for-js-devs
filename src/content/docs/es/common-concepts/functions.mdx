---
title: Funciones
description: Aprende sobre las funciones en Rust y cómo se comparan con JavaScript
---

# Funciones en Rust

Las funciones son bloques de código que realizan una tarea específica. En este documento, exploraremos cómo funcionan las funciones en Rust y cómo se comparan con JavaScript.

## Definición de Funciones

### Declaración de Funciones en JavaScript

JavaScript tiene varias formas de definir funciones:

```javascript
// Declaración de función
function greet(name) {
  return "Hello, " + name + "!";
}

// Expresión de función
const greet = function(name) {
  return "Hello, " + name + "!";
}

// Función flecha (arrow function)
const greet = (name) => {
  return "Hello, " + name + "!";
}

// Función flecha con retorno implícito
const greet = name => "Hello, " + name + "!";
```

### Definición de Funciones en Rust

Rust utiliza la palabra clave `fn` para definir funciones:

```rust
fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}
```

Las principales diferencias:
1. Rust requiere que declares los tipos de parámetros y el tipo de retorno
2. Rust usa una sintaxis más parecida a C/C++ que a JavaScript
3. No hay funciones flecha en Rust (aunque existen closures, que veremos más adelante)

## Cuerpo de la Función

### Declaraciones vs Expresiones

JavaScript distingue entre _declaraciones_ (statements) y _expresiones_ (expressions):

```javascript
// Esto es una declaración
let x = 5;

// Esto es una expresión
2 + 2
```

Rust hace la misma distinción, pero con una diferencia clave: el valor de retorno de una función es la **última expresión** en el cuerpo de la función, sin punto y coma.

```rust
fn add_one(x: i32) -> i32 {
    // Este es el valor de retorno (sin punto y coma al final)
    x + 1
}

// Equivalent a:
fn add_one(x: i32) -> i32 {
    return x + 1;
}
```

En JavaScript necesitas usar la palabra clave `return` explícitamente:

```javascript
function addOne(x) {
    return x + 1;
}
```

## Valores de Retorno

### Retorno Explícito e Implícito

Como se mencionó anteriormente, en Rust, el valor de retorno de una función es la última expresión, sin punto y coma:

```rust
fn add_one(x: i32) -> i32 {
    x + 1  // Retorno implícito
}

fn complex_calculation(x: i32) -> i32 {
    // Retorno anticipado con "return" explícito
    if x < 0 {
        return 0;
    }
    
    // Procesamiento complicado...
    let result = x * 2;
    
    // Retorno implícito
    result
}
```

En JavaScript, generalmente necesitas usar la palabra clave `return` a menos que uses una función flecha con un cuerpo de expresión única:

```javascript
// Retorno explícito
function addOne(x) {
    return x + 1;
}

// Retorno implícito (solo en funciones flecha de una sola expresión)
const addOne = x => x + 1;
```

### El Tipo Unidad en Rust

Si una función no devuelve un valor en Rust, implícitamente devuelve el tipo unidad `()`:

```rust
// Esta función devuelve ()
fn print_hello() {
    println!("Hello!");
}

// Esto es equivalente a:
fn print_hello() -> () {
    println!("Hello!");
}
```

En JavaScript, una función sin un `return` explícito devuelve `undefined`:

```javascript
function printHello() {
    console.log("Hello!");
    // Implícitamente retorna undefined
}
```

### Declaración de Tipo de Retorno

En Rust, el tipo de retorno se declara después de una flecha `->`:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

JavaScript tradicionalmente no declaraba tipos, pero con TypeScript:

```typescript
function add(a: number, b: number): number {
    return a + b;
}
```

## Parámetros de Función

### Parámetros en JavaScript

JavaScript es muy flexible con los parámetros:

```javascript
// Parámetros opcionales
function greet(name, greeting = "Hello") {
    return `${greeting}, ${name}!`;
}

greet("World");           // "Hello, World!"
greet("World", "Hola");   // "Hola, World!"

// Número variable de argumentos con el operador rest
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

sum(1, 2, 3, 4);  // 10
```

### Parámetros en Rust

Rust requiere tipos para todos los parámetros:

```rust
fn greet(name: &str, greeting: &str) -> String {
    format!("{}, {}!", greeting, name)
}
```

Rust no tiene parámetros por defecto como JavaScript, pero puedes usar patrones idiomáticos:

```rust
// Usando Option para parámetros opcionales
fn greet(name: &str, greeting: Option<&str>) -> String {
    let greeting = greeting.unwrap_or("Hello");
    format!("{}, {}!", greeting, name)
}

// Uso:
greet("World", None);             // "Hello, World!"
greet("World", Some("Hola"));     // "Hola, World!"
```

## Sobrecarga de Funciones

JavaScript no soporta directamente la sobrecarga de funciones (múltiples funciones con el mismo nombre pero diferentes parámetros):

```javascript
// La segunda definición sobreescribe la primera
function process(x) { return x * 2; }
function process(x, y) { return x + y; }  // Esta es la que cuenta

// En su lugar, usamos parámetros opcionales o verificación de tipo
function process(x, y) {
    if (y === undefined) {
        return x * 2;
    } else {
        return x + y;
    }
}
```

Rust tampoco tiene sobrecarga de funciones directamente. En su lugar, proporciona otras opciones:

```rust
// Diferentes nombres de función
fn double(x: i32) -> i32 {
    x * 2
}

fn add(x: i32, y: i32) -> i32 {
    x + y
}

// O usar traits (cubiertos más adelante)
// O usar diferentes tipos con el mismo nombre de función a través de impl
```

## La Función Principal (main)

En JavaScript para el navegador, no hay una función principal explícita. El código simplemente se ejecuta de arriba a abajo. En Node.js, el archivo que ejecutas es efectivamente el "principal":

```javascript
// app.js - punto de entrada de la aplicación
console.log("Starting application...");
// Code...
```

En Rust, la función `main()` es el punto de entrada para los programas ejecutables:

```rust
fn main() {
    println!("Starting application...");
    // Code...
}
```

## Pasar Funciones como Argumentos

### Funciones de Orden Superior en JavaScript

JavaScript trata las funciones como ciudadanos de primera clase, lo que facilita pasarlas como argumentos:

```javascript
function applyOperation(x, y, operation) {
    return operation(x, y);
}

// Pasar funciones como argumentos
const sum = applyOperation(5, 3, (a, b) => a + b);    // 8
const product = applyOperation(5, 3, (a, b) => a * b); // 15
```

### Funciones de Orden Superior en Rust

Rust también permite funciones de orden superior, pero la sintaxis es diferente:

```rust
fn apply_operation<F>(x: i32, y: i32, operation: F) -> i32
where
    F: Fn(i32, i32) -> i32,
{
    operation(x, y)
}

fn main() {
    // Función anónima (closure)
    let sum = apply_operation(5, 3, |a, b| a + b);        // 8
    let product = apply_operation(5, 3, |a, b| a * b);    // 15
    
    // También se pueden pasar funciones con nombre
    fn multiply(a: i32, b: i32) -> i32 {
        a * b
    }
    
    let result = apply_operation(5, 3, multiply);         // 15
}
```

## Closures

Las closures (o clausuras) son funciones que capturan su entorno.

### Closures en JavaScript

```javascript
function createMultiplier(factor) {
    // Esta función interior captura 'factor' del entorno
    return function(x) {
        return x * factor;
    };
}

const double = createMultiplier(2);
double(5);  // 10
```

### Closures en Rust

```rust
fn create_multiplier(factor: i32) -> impl Fn(i32) -> i32 {
    move |x| x * factor
}

fn main() {
    let double = create_multiplier(2);
    println!("{}", double(5));  // 10
}
```

Rust tiene tres tipos de closures:
1. `Fn` - Captura por referencia (`&T`)
2. `FnMut` - Captura por referencia mutable (`&mut T`)
3. `FnOnce` - Captura por valor (`T`)

```rust
// Closure que captura por referencia (&T)
fn main() {
    let text = String::from("Hello");
    
    let print_text = || {
        println!("{}", text);  // Usa text por referencia
    };
    
    print_text();
    
    // Aún podemos usar 'text' porque solo se tomó prestado
    println!("I can still use {}", text);
}

// Closure que captura por referencia mutable (&mut T)
fn main() {
    let mut counter = 0;
    
    let mut increment = || {
        counter += 1;  // Modifica counter
    };
    
    increment();
    increment();
    
    println!("Counter: {}", counter);  // 2
}

// Closure que captura por valor (T)
fn main() {
    let text = String::from("Hello");
    
    let consume_text = move || {
        let t = text;  // 'text' se mueve aquí
        println!("{}", t);
    };
    
    consume_text();
    
    // Ya no podemos usar 'text' porque fue movido
    // println!("{}", text);  // ❌ Error: valor usado después de ser movido
}
```

## Métodos

### Métodos en JavaScript

En JavaScript, los métodos son funciones que pertenecen a objetos:

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
    
    greet() {
        return `Hello, my name is ${this.name}`;
    }
    
    // Método estático
    static create(name) {
        return new Person(name);
    }
}

const alice = new Person("Alice");
alice.greet();  // "Hello, my name is Alice"

// Método estático
const bob = Person.create("Bob");
```

### Métodos en Rust

En Rust, los métodos están asociados a tipos a través de bloques `impl`:

```rust
struct Person {
    name: String,
}

impl Person {
    // Método (toma &self)
    fn greet(&self) -> String {
        format!("Hello, my name is {}", self.name)
    }
    
    // Método mutable (toma &mut self)
    fn change_name(&mut self, new_name: String) {
        self.name = new_name;
    }
    
    // Función asociada (no toma self)
    fn create(name: String) -> Person {
        Person { name }
    }
}

fn main() {
    let mut alice = Person { name: String::from("Alice") };
    
    // Llamada a método
    println!("{}", alice.greet());
    
    // Llamada a método mutable
    alice.change_name(String::from("Alicia"));
    
    // Llamada a función asociada con sintaxis de ruta
    let bob = Person::create(String::from("Bob"));
}
```

## Funciones Asociadas

Las funciones asociadas en Rust son similares a los métodos estáticos en JavaScript. No toman `self` como parámetro:

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // Función asociada (como un constructor)
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
    
    // Método regular
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    // Usando la función asociada
    let square = Rectangle::square(10);
    
    // Usando el método
    println!("Area: {}", square.area());  // 100
}
```

En JavaScript, sería algo así:

```javascript
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    
    // Método estático (equivalente a una función asociada)
    static square(size) {
        return new Rectangle(size, size);
    }
    
    // Método regular
    area() {
        return this.width * this.height;
    }
}

const square = Rectangle.square(10);
console.log("Area:", square.area());  // 100
```

## Documentación de Funciones

### Documentación en JavaScript

En JavaScript, generalmente se utilizan comentarios JSDoc para documentar funciones:

```javascript
/**
 * Calculates the sum of two numbers.
 * 
 * @param {number} a - The first number
 * @param {number} b - The second number
 * @returns {number} The sum of a and b
 */
function add(a, b) {
    return a + b;
}
```

### Documentación en Rust

Rust utiliza comentarios de documentación que comienzan con tres barras (`///`):

```rust
/// Calculates the sum of two numbers.
/// 
/// # Examples
/// 
/// ```
/// let result = add(2, 3);
/// assert_eq!(result, 5);
/// ```
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

Los comentarios de documentación de Rust admiten Markdown y se pueden compilar en documentación HTML con `cargo doc`.

## Diferencias Clave Entre JavaScript y Rust

1. **Tipado**: JavaScript es dinámicamente tipado, mientras que Rust es estáticamente tipado y requiere anotaciones de tipo para parámetros y valores de retorno.

2. **Retorno**: Rust permite retornos implícitos con la última expresión, mientras que JavaScript generalmente requiere la palabra clave `return` (excepto en algunas funciones flecha).

3. **Parámetros por defecto**: JavaScript tiene parámetros por defecto integrados, mientras que Rust usa patrones como `Option<T>` para lograr funcionalidad similar.

4. **Sobrecarga de funciones**: Ninguno de los dos lenguajes admite directamente la sobrecarga de funciones, pero JavaScript es más flexible debido a su sistema de tipos dinámico.

5. **Closures**: Ambos lenguajes admiten closures, pero Rust tiene un sistema más formal con diferentes tipos de closures según cómo capturan las variables.

6. **Métodos**: JavaScript utiliza clases o prototipos para métodos, mientras que Rust utiliza bloques `impl` para asociar métodos con tipos.

7. **Funciones puras vs impuras**: Rust fomenta las funciones puras (sin efectos secundarios) a través de su sistema de propiedad, mientras que JavaScript deja esto a discreción del desarrollador.

## Próximos Pasos

Ahora que entiendes cómo funcionan las funciones en Rust, estás listo para explorar conceptos más avanzados como [Control de Flujo](/es/common-concepts/control-flow/), donde veremos cómo Rust maneja las declaraciones condicionales, los bucles y otros mecanismos de control. 