---
title: Tipos de Datos
description: Aprende sobre los tipos de datos de Rust y cómo se comparan con JavaScript
---

# Tipos de Datos en Rust

El sistema de tipos de Rust es una de las principales diferencias respecto a JavaScript. Exploremos los diversos tipos de datos en Rust y cómo se comparan con JavaScript.

## Sistemas de Tipos: Estático vs Dinámico

JavaScript es **dinámicamente tipado**, lo que significa que las variables pueden cambiar de tipo en tiempo de ejecución:

```javascript
let value = 42;      // Number
value = "hello";     // Now it's a String
value = true;        // Now it's a Boolean
```

Rust es **estáticamente tipado**, lo que significa que el tipo de cada variable debe conocerse en tiempo de compilación:

```rust
let value = 42;      // i32 by default
// value = "hello";  // ❌ Error: mismatched types
// value = true;     // ❌ Error: mismatched types
```

En Rust, puedes anotar los tipos explícitamente:

```rust
let age: u32 = 30;
let name: String = String::from("Alice");
let is_active: bool = true;
```

## Tipos Escalares

### Enteros

JavaScript tiene un único tipo numérico (`Number`) para enteros y valores de punto flotante, además de `BigInt` para enteros grandes.

Rust tiene múltiples tipos de enteros basados en el tamaño y el signo:

| Tipo   | Tamaño (bits) | Rango                                      | Equivalente en JS |
|--------|---------------|--------------------------------------------|--------------------|
| `i8`   | 8             | -128 a 127                                 | `Number`           |
| `u8`   | 8             | 0 a 255                                    | `Number`           |
| `i16`  | 16            | -32,768 a 32,767                           | `Number`           |
| `u16`  | 16            | 0 a 65,535                                 | `Number`           |
| `i32`  | 32            | -2,147,483,648 a 2,147,483,647             | `Number`           |
| `u32`  | 32            | 0 a 4,294,967,295                          | `Number`           |
| `i64`  | 64            | -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 | `BigInt` |
| `u64`  | 64            | 0 a 18,446,744,073,709,551,615             | `BigInt`           |
| `i128` | 128           | Rango muy grande                           | `BigInt`           |
| `u128` | 128           | Rango muy grande                           | `BigInt`           |
| `isize`| arq           | Depende de la arquitectura                 | `Number`           |
| `usize`| arq           | Depende de la arquitectura                 | `Number`           |

```rust
let a: i32 = 42;        // 32-bit signed integer
let b: u64 = 1000000;   // 64-bit unsigned integer
let c = 98_222;         // Underscores for readability, like 98,222
let d = 0xff;           // Hex value
let e = 0o77;           // Octal value
let f = 0b1111_0000;    // Binary value
```

En JavaScript, todos estos serían:

```javascript
const a = 42;           // Number
const b = 1000000;      // Number
const c = 98222;        // Number
const d = 0xff;         // Hex value (255)
const e = 0o77;         // Octal value (63)
const f = 0b11110000;   // Binary value (240)
const g = 9007199254740992n; // BigInt for numbers > 2^53
```

### Números de Punto Flotante

Rust tiene dos tipos de punto flotante:

| Tipo  | Tamaño (bits) | Precisión         | Equivalente en JS |
|-------|---------------|-------------------|--------------------|
| `f32` | 32            | Precisión simple  | `Number`           |
| `f64` | 64            | Precisión doble   | `Number`           |

```rust
let x: f64 = 2.0;       // Double-precision float (default)
let y: f32 = 3.0;       // Single-precision float
```

En JavaScript:

```javascript
const x = 2.0;         // Number (always double precision)
```

### Booleanos

Ambos lenguajes tienen tipos booleanos:

```rust
let t: bool = true;
let f: bool = false;
```

```javascript
const t = true;
const f = false;
```

### Caracteres

JavaScript no tiene un tipo de carácter dedicado; los caracteres individuales son simplemente cadenas de longitud 1.

El tipo `char` de Rust representa un valor escalar Unicode:

```rust
let c: char = 'z';
let z: char = 'ℤ';
let heart: char = '❤';
```

En JavaScript:

```javascript
const c = 'z';        // String of length 1
const z = 'ℤ';        // String of length 1 (but 2 bytes in UTF-16)
const heart = '❤';    // String of length 1 (but 2 bytes in UTF-16)
```

## Tipos Compuestos

### Tuplas

Rust tiene tuplas, que son colecciones de longitud fija de valores de diferentes tipos:

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

// Destructuring
let (x, y, z) = tup;
println!("y is: {}", y);  // 6.4

// Accessing by index
let five_hundred = tup.0;  // 500
```

JavaScript agregó un comportamiento similar a las tuplas con la desestructuración de arrays:

```javascript
// JavaScript doesn't have real tuples, but we can use arrays
const tup = [500, 6.4, 1];

// Destructuring
const [x, y, z] = tup;
console.log(y);  // 6.4

// Accessing by index
const fiveHundred = tup[0];  // 500
```

### Arrays

Los arrays de Rust tienen una longitud fija y contienen elementos del mismo tipo:

```rust
// Array with 5 elements of type i32
let a: [i32; 5] = [1, 2, 3, 4, 5];

// Initialize an array with the same value repeated
let b = [3; 5];  // Equivalent to [3, 3, 3, 3, 3]

// Access elements
let first = a[0];  // 1
```

Los arrays de JavaScript son dinámicos y pueden contener elementos de diferentes tipos:

```javascript
// JavaScript arrays are dynamic
const a = [1, 2, 3, 4, 5];
a.push(6);  // Can add elements

// Can contain mixed types
const mixed = [1, "two", true, { four: 4 }];

// Access elements the same way
const first = a[0];  // 1
```

Para arrays dinámicos en Rust, usarías un `Vec` (vector), que cubriremos en la sección de Colecciones.

## Strings

Los strings son un tema complejo en Rust, especialmente viniendo de JavaScript.

### Strings en JavaScript

En JavaScript, los strings son simples:

```javascript
const greeting = "Hello, world!";
const name = 'Alice';
const template = `Hello, ${name}!`;

// String methods
const upperName = name.toUpperCase();
const sub = greeting.substring(0, 5);  // "Hello"
```

### Strings en Rust

Rust tiene dos tipos de string: `String` y `&str`:

```rust
// String literals are &str (string slices)
let greeting: &str = "Hello, world!";

// String type is growable, heap-allocated
let mut name = String::from("Alice");
name.push_str(" Smith");  // Now "Alice Smith"

// Creating a String from a &str
let s = "initial".to_string();
let s = String::from("initial");

// Concatenation
let hello = String::from("Hello, ");
let world = String::from("world!");
let hello_world = hello + &world;  // Note: hello is moved here

// Format macro (like template literals)
let name = "Alice";
let greeting = format!("Hello, {}!", name);
```

Las principales diferencias:
- `&str` es inmutable and se usa a menudo para literales de string or vistas en strings
- `String` es ampliable, asignado en el montón, y propio
- Los strings de Rust están codificados en UTF-8, lo que afecta cómo se indexan y manipulan

## Conversión de Tipos

### Coerción de Tipos en JavaScript

JavaScript a menudo realiza conversión implícita de tipos:

```javascript
console.log("5" + 1);      // "51" (string)
console.log("5" - 1);      // 4 (number)
console.log(5 + true);     // 6 (number)
```

### Conversión Explícita en Rust

Rust requiere conversión explícita:

```rust
let x = 5;
// let y = x + "10";  // ❌ Error: cannot add `&str` to `{integer}`

// Explicit conversion
let y = x + 10;       // 15
let s = x.to_string() + "10";  // "510"
let z = x + "10".parse::<i32>().unwrap();  // 15
```

## Tipos Especiales

### El Tipo Unidad

Rust tiene un tipo unidad `()`, que representa la ausencia de un valor:

```rust
// Functions with no return value implicitly return the unit type
fn do_something() {
    println!("Hello");
    // Implicitly returns () 
}
```

JavaScript no tiene un equivalente; las funciones que no devuelven nada implícitamente devuelven `undefined`.

### El Tipo Option

En lugar de `null` o `undefined`, Rust usa `Option<T>` para representar un valor que podría estar ausente:

```rust
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;

// Using Option requires handling both cases
match some_number {
    Some(n) => println!("Got a number: {}", n),
    None => println!("No number"),
}
```

Equivalente en JavaScript:

```javascript
const someNumber = 5;
const someString = "a string";
const absentNumber = null;

// Check for null/undefined
if (someNumber !== null && someNumber !== undefined) {
    console.log(`Got a number: ${someNumber}`);
} else {
    console.log("No number");
}
```

## Inferencia de Tipos

Ambos lenguajes pueden inferir tipos, pero la inferencia de Rust es más sofisticada y ocurre en tiempo de compilación:

```rust
// Rust infers these types
let x = 5;        // i32
let y = 3.0;      // f64
let active = true;  // bool
```

```javascript
// JavaScript also has type inference, but at runtime
let x = 5;        // number
let y = 3.0;      // number
let active = true;  // boolean
```

## Alias de Tipos

Rust permite crear alias de tipos:

```rust
type Kilometers = i32;

let distance: Kilometers = 5;
```

En JavaScript con TypeScript:

```typescript
type Kilometers = number;

let distance: Kilometers = 5;
```

## Próximos Pasos

Ahora que entiendes los tipos de datos de Rust, estás listo para pasar a [Funciones](/es/common-concepts/functions/), donde exploraremos cómo definir y usar funciones en Rust en comparación con JavaScript. 