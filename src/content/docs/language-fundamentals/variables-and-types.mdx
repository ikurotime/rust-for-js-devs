---
title: Variables and Types
description: How variables and types work in Rust compared to JavaScript
---

# Variables and Types in Rust

One of the most noticeable differences between Rust and JavaScript is how variables and types work. Let's explore these differences to help you transition between the two languages.

## Variables Declaration

### JavaScript

In JavaScript, you can declare variables with `var`, `let`, or `const`:

```javascript
// JavaScript variable declarations
var oldSchool = "I'm hoisted";
let mutable = "I can be changed";
const immutable = "I cannot be changed";

// Reassignment
mutable = "New value";  // ✅ Works
// immutable = "New value";  // ❌ TypeError: Assignment to constant variable
```

### Rust

In Rust, variables are declared with `let` and are **immutable by default**:

```rust
// Rust variable declarations
let immutable = "I cannot be changed"; // Immutable by default
let mut mutable = "I can be changed";  // Use 'mut' to make mutable

// Reassignment
// immutable = "New value";  // ❌ Error: cannot assign twice to immutable variable
mutable = "New value";      // ✅ Works
```

This is a significant difference: In JavaScript, variables declared with `let` are mutable by default, while in Rust, variables are immutable by default and you need to use `mut` to make them mutable.

## Type System

### JavaScript

JavaScript is **dynamically typed**, which means:
- Variable types are determined at runtime
- Types can change during execution
- Type errors might only be caught at runtime

```javascript
// JavaScript dynamic typing
let value = "Hello";  // String
value = 42;           // Now it's a Number
value = true;         // Now it's a Boolean

// This might cause runtime errors
console.log(value.toUpperCase());  // ❌ TypeError: value.toUpperCase is not a function
```

### Rust

Rust is **statically typed**, which means:
- Types are checked at compile time
- Types cannot change during execution
- Type errors are caught before your program runs

```rust
// Rust static typing
let value: &str = "Hello";  // String slice type
// value = 42;  // ❌ Error: expected &str, found integer

// Type can be inferred
let inferred_value = "Hello";  // Rust knows this is a &str

// This won't compile
// println!("{}", inferred_value + 10);  // ❌ Error: cannot add `{integer}` to `&str`
```

## Basic Types in Rust

Here's a comparison of basic types between JavaScript and Rust:

| JavaScript | Rust | Description |
|------------|------|-------------|
| `number` | `i32`, `i64`, `f32`, `f64`, etc. | Rust has specific integer and float types with specific sizes |
| `string` | `String`, `&str` | Rust has different string types for owned and borrowed strings |
| `boolean` | `bool` | Boolean values (`true` or `false`) |
| `null`, `undefined` | `Option<T>` | Rust uses `Option` enum instead of null values |
| `Array` | `Vec<T>`, arrays `[T; N]` | Dynamic arrays are `Vec`, fixed-size are arrays |
| `Object` | `struct`, `enum` | Rust uses structs and enums for data structures |

## Type Annotations in Rust

While Rust can infer types in most cases, you can explicitly annotate types:

```rust
let integer: i32 = 42;
let float: f64 = 3.14;
let boolean: bool = true;
let character: char = 'A';
let string: String = String::from("Hello");
let string_slice: &str = "Hello";
```

## Constants

### JavaScript

JavaScript has `const` for constants, but this only prevents reassignment, not mutation of objects:

```javascript
const PI = 3.14159;
// PI = 3.0;  // ❌ Error: Assignment to constant variable

const user = { name: "Alice" };
user.name = "Bob";  // ✅ Works - only the binding is constant, not the content
```

### Rust

Rust has `const` for true constants, which:
- Must have type annotations
- Must be assigned values that can be determined at compile time
- Are evaluated at compile time, not runtime
- Can be declared in any scope, including global scope

```rust
const PI: f64 = 3.14159;
// PI = 3.0;  // ❌ Error: cannot assign to this expression

// Constants use SCREAMING_SNAKE_CASE by convention
const MAX_POINTS: u32 = 100_000;
```

## Examples: JavaScript vs Rust

### Variable Shadowing

JavaScript:
```javascript
let x = 10;
let x = 20;  // ❌ SyntaxError: Identifier 'x' has already been declared

{
  let x = 20;  // ✅ Works - this is a different 'x' in a new block scope
  console.log(x);  // 20
}
console.log(x);  // 10
```

Rust:
```rust
let x = 10;
let x = 20;  // ✅ Works - this shadows the previous 'x'
println!("{}", x);  // 20

{
  let x = 30;  // ✅ Works - this shadows within this block
  println!("{}", x);  // 30
}
println!("{}", x);  // 20
```

Shadowing in Rust is a powerful feature that allows you to reuse variable names while changing types:

```rust
// This is valid Rust code
let value = "42";       // value is a &str
let value = value.len(); // value is now a usize (the length of the string)
let value = value * 2;   // value is now the result of multiplication
```

## Key Takeaways

1. Rust variables are immutable by default, JavaScript's are mutable by default
2. Rust is statically typed, JavaScript is dynamically typed
3. Rust catches type errors at compile time, JavaScript at runtime
4. Rust has richer primitive types (different integer and float sizes)
5. Rust allows shadowing of variables with the same name

In the next section, we'll explore [control flow](/language-fundamentals/control-flow/) in Rust and how it compares to JavaScript. 