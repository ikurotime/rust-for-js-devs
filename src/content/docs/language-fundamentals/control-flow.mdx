---
title: Control Flow in Rust
description: Learn about conditionals, loops, and other control flow structures in Rust
---

# Control Flow in Rust

Control flow in Rust is similar to JavaScript in many ways, but with some important differences. Let's explore how conditionals, loops, and pattern matching work in Rust.

## Conditionals

### If Expressions

In JavaScript, `if` statements work like this:

```javascript
// JavaScript if statements
let num = 5;

if (num > 0) {
  console.log("Positive");
} else if (num < 0) {
  console.log("Negative");
} else {
  console.log("Zero");
}
```

In Rust, `if` is an expression (returns a value), not just a statement:

```rust
// Rust if expressions
let num = 5;

if num > 0 {
    println!("Positive");
} else if num < 0 {
    println!("Negative");
} else {
    println!("Zero");
}
```

Key differences from JavaScript:
1. No parentheses `()` around conditions (though they're optional)
2. Condition must be a boolean expression (no truthy/falsy values)
3. Braces `{}` are required even for single statements

### If as an Expression

Since `if` is an expression in Rust, you can assign its result to a variable:

```rust
let num = 5;
let sign = if num > 0 {
    "positive"
} else if num < 0 {
    "negative"
} else {
    "zero"
};

println!("The number is {}", sign);
```

This is similar to the ternary operator in JavaScript:

```javascript
const num = 5;
const sign = num > 0 ? "positive" : num < 0 ? "negative" : "zero";

console.log(`The number is ${sign}`);
```

## Loops

Rust provides several ways to loop:

### Loop (Infinite)

The `loop` keyword creates an infinite loop:

```rust
// Rust infinite loop
loop {
    println!("Forever!");
    
    // Use break to exit the loop
    if something_happened() {
        break;
    }
}
```

In JavaScript, you'd use `while (true)`:

```javascript
// JavaScript infinite loop
while (true) {
  console.log("Forever!");
  
  if (somethingHappened()) {
    break;
  }
}
```

### While Loops

While loops in Rust and JavaScript are very similar:

```rust
// Rust while loop
let mut count = 0;
while count < 5 {
    println!("Count: {}", count);
    count += 1;
}
```

```javascript
// JavaScript while loop
let count = 0;
while (count < 5) {
  console.log(`Count: ${count}`);
  count += 1;
}
```

### For Loops

For loops in Rust are quite different from JavaScript's C-style for loops. Rust uses a for-in loop that iterates over an iterator:

```rust
// Rust for loop
for num in 0..5 {
    println!("Number: {}", num);
}

// Iterating over an array
let numbers = [1, 2, 3, 4, 5];
for num in numbers.iter() {
    println!("Number: {}", num);
}
```

In JavaScript, you'd use:

```javascript
// JavaScript for loop (similar to Rust's range)
for (let i = 0; i < 5; i++) {
  console.log(`Number: ${i}`);
}

// JavaScript for-of loop (similar to Rust's for-in)
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers) {
  console.log(`Number: ${num}`);
}
```

### Loop Labels

Rust supports loop labels to break from nested loops:

```rust
'outer: for x in 0..5 {
    for y in 0..5 {
        if x * y > 10 {
            println!("Breaking at x={}, y={}", x, y);
            break 'outer;
        }
    }
}
```

In JavaScript, you'd need to use labeled statements, which are less common:

```javascript
outer: for (let x = 0; x < 5; x++) {
  for (let y = 0; y < 5; y++) {
    if (x * y > 10) {
      console.log(`Breaking at x=${x}, y=${y}`);
      break outer;
    }
  }
}
```

## Pattern Matching with match

One of Rust's most powerful features is the `match` expression, which is like a sophisticated switch statement:

```rust
let number = 13;

match number {
    // Match a single value
    1 => println!("One!"),
    
    // Match multiple values
    2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
    
    // Match a range
    13..=19 => println!("A teen"),
    
    // Default case
    _ => println!("Not interesting"),
}
```

The JavaScript equivalent would be:

```javascript
const number = 13;

switch (number) {
  case 1:
    console.log("One!");
    break;
  case 2:
  case 3: 
  case 5:
  case 7:
  case 11:
    console.log("This is a prime");
    break;
  case 13:
  case 14:
  case 15:
  case 16:
  case 17:
  case 18:
  case 19:
    console.log("A teen");
    break;
  default:
    console.log("Not interesting");
}
```

But `match` in Rust is much more powerful because:
1. It's an expression (returns a value)
2. It enforces exhaustive checking (all possible values must be covered)
3. It supports complex pattern matching with destructuring

### Using match as an Expression

```rust
let boolean = true;
let binary = match boolean {
    false => 0,
    true => 1,
};
```

### Pattern Matching with Structs and Enums

Match is especially powerful with enums (we'll see more in the Enums section):

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
    }
}
```

## if let Syntax

For simpler pattern matching, Rust offers the `if let` syntax:

```rust
let some_value = Some(3);

// Using match
match some_value {
    Some(3) => println!("three!"),
    _ => (),
}

// Using if let (more concise)
if let Some(3) = some_value {
    println!("three!");
}
```

In JavaScript, you might use destructuring with optional chaining:

```javascript
const someValue = { value: 3 };

if (someValue?.value === 3) {
  console.log("three!");
}
```

## Key Differences from JavaScript

1. **Type Safety**: Rust's conditionals must have boolean types, not truthy/falsy values
2. **Expression-based**: Most control flow in Rust returns values
3. **Pattern Matching**: Rust's `match` is much more powerful than JavaScript's `switch`
4. **Exhaustiveness**: Rust ensures you handle all possible cases
5. **Range-based Looping**: Rust has more ergonomic constructs for iterating over ranges

In the next section, we'll explore [Functions](/language-fundamentals/functions/) in Rust. 