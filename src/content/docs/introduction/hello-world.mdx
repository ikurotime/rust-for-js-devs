---
title: Hello, World!
description: Write your first Rust program and compare it with JavaScript
---

# Hello, World!

Let's write our first Rust program! This is a tradition when learning a new programming language, and it's a great way to verify that your Rust installation is working correctly.

## Creating a Project Directory

First, let's create a directory for our project:

```bash
mkdir hello_world
cd hello_world
```

## Creating a Rust Source File

In Rust, source files have a `.rs` extension. Let's create a file called `main.rs`:

```bash
touch main.rs   # On macOS/Linux
# OR
echo > main.rs  # On Windows
```

Open this file in your editor and add the following code:

```rust
fn main() {
    println!("Hello, World!");
}
```

## Comparing with JavaScript

Here's how a similar program would look in JavaScript:

```javascript
console.log("Hello, World!");
```

Let's compare these two programs:

| Rust | JavaScript | Notes |
|------|------------|-------|
| `fn main() { ... }` | Not needed | Rust programs start execution from the `main` function |
| `println!("Hello, World!");` | `console.log("Hello, World!");` | Rust uses macros (with `!`) for printing |

## Compiling and Running the Program

Unlike JavaScript, which is interpreted, Rust is a compiled language. This means we need to compile our code before running it.

### Compiling

```bash
rustc main.rs
```

This will create an executable file in the same directory.

### Running

On macOS/Linux:
```bash
./hello_world
```

On Windows:
```bash
.\hello_world.exe
```

You should see:
```
Hello, World!
```

## Understanding Rust's Compilation Model

This compilation step is a key difference from JavaScript:

1. **JavaScript**: The code is typically interpreted at runtime (though JIT compilation often happens behind the scenes)
2. **Rust**: The code is compiled ahead of time into a binary executable

This compilation model offers several advantages:
- Catches errors at compile time rather than runtime
- Produces highly optimized, fast executables
- No need for a runtime environment (like Node.js)

## Function Structure

Let's take another look at our Rust function:

```rust
fn main() {
    println!("Hello, World!");
}
```

- `fn` declares a function (similar to `function` in JavaScript)
- `main` is the function name (special because it's the entry point)
- Empty parentheses `()` means this function takes no parameters
- Code inside the function is enclosed in curly braces `{}`

## Macros vs. Functions

In our example, `println!` is a macro, not a function. You can identify macros in Rust by the exclamation mark (`!`).

Macros are more powerful than functions because they can:
- Generate code at compile time
- Take a variable number of arguments
- Implement features that would be difficult with normal functions

## The Semi-Colon in Rust

Just like in JavaScript, statements in Rust end with a semicolon (`;`). But in Rust, semicolons also indicate that an expression should not return a value, which we'll explore more when we discuss functions in detail.

## Rust Formatting Style

Rust has a standard formatting style, similar to how JavaScript has tools like Prettier:

- 4 spaces for indentation (not tabs)
- Curly braces on the same line as control flow statements

You can automatically format your Rust code with:

```bash
rustfmt main.rs
```

## Next Steps

While you can write all your programs like this and compile them with `rustc`, most Rust developers use Cargo, Rust's build system and package manager. Let's move on to [Hello, Cargo!](/introduction/hello-cargo/) to learn how to use it. 